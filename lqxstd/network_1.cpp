#include "stdafx.h"

#include "network.h"

#pragma comment(lib, "wlanapi.lib")

namespace lqx {

	BOOL _network_1_Enabled = FALSE;

	void QueryHostedNetwork(_HostedNetworkInfo *HostedNetworkInfo)
	{

		HANDLE ClientHandle;
		DWORD NegotiatedVersion;

		//获得承载网络的句柄
		if (WlanOpenHandle(2, NULL, &NegotiatedVersion, &ClientHandle) != ERROR_SUCCESS)
			throw "WlanOpenHandle调用失败。";
		//如果从未对承载网络进行设置，则先自动配置承载网络。如果已经配置过（比如设置了SSID，密码之类的），则保留原有设置。
		if (WlanHostedNetworkInitSettings(ClientHandle, NULL, NULL) != ERROR_SUCCESS)
			throw "WlanHostedNetworkInitSettings调用失败。";
		

		//获取网卡状态
		PWLAN_HOSTED_NETWORK_STATUS pHostedNetworkStatus = NULL;
		if (WlanHostedNetworkQueryStatus(ClientHandle, &pHostedNetworkStatus, NULL) != ERROR_SUCCESS)
			throw("WlanHostedNetworkQueryStatus调用失败。");
		if (pHostedNetworkStatus->HostedNetworkState != wlan_hosted_network_active)  //是否正在运行
			HostedNetworkInfo->Active = false;
		else
			HostedNetworkInfo->Active = true;
		HostedNetworkInfo->NumberOfPeers = pHostedNetworkStatus->dwNumberOfPeers;    //当前连接数
		WlanFreeMemory(pHostedNetworkStatus);


		//查看是否已启用承载网络（即netsh wlan set hostednetwork mode=allow/disallow设置的内容）
		DWORD ReturnValue;
		DWORD DataSize;
		PBOOL pEnabled = NULL;
		WLAN_OPCODE_VALUE_TYPE WlanOpcodeValueType;
		ReturnValue = WlanHostedNetworkQueryProperty(
			ClientHandle,
			wlan_hosted_network_opcode_enable,
			&DataSize,
			(PVOID*)&pEnabled,
			&WlanOpcodeValueType,
			NULL
		);
		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkQueryProperty调用失败。";
		_network_1_Enabled = *pEnabled;
		WlanFreeMemory(pEnabled);


		//获取当前承载网络的配置情况
		ULONG SSIDLengthInBytes;
		UCHAR *SSID_;
		PWLAN_HOSTED_NETWORK_CONNECTION_SETTINGS pHostedNetworkConnectionSettings = NULL;
		ReturnValue = WlanHostedNetworkQueryProperty(
			ClientHandle,
			wlan_hosted_network_opcode_connection_settings,
			&DataSize,
			(PVOID*)&pHostedNetworkConnectionSettings,
			&WlanOpcodeValueType,
			NULL
		);

		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkQueryProperty调用失败。";
		SSIDLengthInBytes = pHostedNetworkConnectionSettings->hostedNetworkSSID.uSSIDLength;  //SSID长度（不包括\0）
		SSID_ = pHostedNetworkConnectionSettings->hostedNetworkSSID.ucSSID;                   //SSID字符串
		strcpy_s(HostedNetworkInfo->SSID, 32, (char*)SSID_);
		HostedNetworkInfo->MaxNumberOfPeers = pHostedNetworkConnectionSettings->dwMaxNumberOfPeers; //最大连接数
		WlanFreeMemory(pHostedNetworkConnectionSettings);


		//获得当前设置的密码
		DWORD KeyLength;
		PUCHAR KeyData;
		BOOL IsPassPhrase;
		BOOL Persistent;
		WLAN_HOSTED_NETWORK_REASON FailReason;
		ReturnValue = WlanHostedNetworkQuerySecondaryKey(
			ClientHandle,
			&KeyLength,
			&KeyData,
			&IsPassPhrase,
			&Persistent,
			&FailReason,
			NULL
		);
		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkQuerySecondaryKey调用失败。";
		if (IsPassPhrase) {
			HostedNetworkInfo->IsPassPhase = true;
			strcpy_s(HostedNetworkInfo->Key, 64, (char*)KeyData);
		}
		else {
			HostedNetworkInfo->IsPassPhase = false;
			memcpy_s(HostedNetworkInfo->Key, 64, KeyData, 32);
		}
		WlanFreeMemory(KeyData);


		//获取认证方式，加密算法
		PWLAN_HOSTED_NETWORK_SECURITY_SETTINGS pHostedNetworkSecuritySettings = NULL;
		ReturnValue = WlanHostedNetworkQueryProperty(
			ClientHandle,
			wlan_hosted_network_opcode_security_settings,
			&DataSize,
			(PVOID*)&pHostedNetworkSecuritySettings,
			&WlanOpcodeValueType,
			NULL
		);
		HostedNetworkInfo->dot11AuthAlgo = pHostedNetworkSecuritySettings->dot11AuthAlgo;
		HostedNetworkInfo->dot11CipherAlgo = pHostedNetworkSecuritySettings->dot11CipherAlgo;
		WlanFreeMemory(pHostedNetworkSecuritySettings);


		WlanCloseHandle(ClientHandle, NULL);

	}



	void SetHostedNetwork(_HostedNetworkInfo *HostedNetworkInfo)
	{

		HANDLE ClientHandle;
		DWORD NegotiatedVersion;

		if (WlanOpenHandle(2, NULL, &NegotiatedVersion, &ClientHandle) != ERROR_SUCCESS)
			throw "WlanOpenHandle调用失败。";

		//配置承载网络（SSID以及最大连接数）
		DWORD ReturnValue;
		WLAN_HOSTED_NETWORK_REASON FailReason;
		WLAN_HOSTED_NETWORK_CONNECTION_SETTINGS HostedNetworkConnectionSettings;
		DOT11_SSID Dot11SSID;
		strcpy_s((char*)Dot11SSID.ucSSID, 32, (char*)(HostedNetworkInfo->SSID));
		Dot11SSID.uSSIDLength = strlen((char*)(HostedNetworkInfo->SSID));
		HostedNetworkConnectionSettings.dwMaxNumberOfPeers = HostedNetworkInfo->MaxNumberOfPeers;
		HostedNetworkConnectionSettings.hostedNetworkSSID = Dot11SSID;
		ReturnValue = WlanHostedNetworkSetProperty(
			ClientHandle,
			wlan_hosted_network_opcode_connection_settings,
			sizeof(HostedNetworkConnectionSettings),
			(PVOID)&HostedNetworkConnectionSettings,
			&FailReason,
			NULL
		);
		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkSetProperty调用失败。";


		//设置密码
		if (HostedNetworkInfo->IsPassPhase) {     //密码为字符串
			ReturnValue = WlanHostedNetworkSetSecondaryKey(
				ClientHandle,
				strlen((char*)(HostedNetworkInfo->Key)) + 1,   //(这里的长度规定把'\0'算在内)
				(PUCHAR)(HostedNetworkInfo->Key),
				TRUE,
				TRUE,
				&FailReason,
				NULL
			);
		}
		else {                                    //密码为32字节的二进制数据
			ReturnValue = WlanHostedNetworkSetSecondaryKey(
				ClientHandle,
				32,
				(PUCHAR)(HostedNetworkInfo->Key),
				FALSE,
				TRUE,
				&FailReason,
				NULL
			);
		}
		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkSetSecondaryKey调用失败。";

		WlanCloseHandle(ClientHandle, NULL);
	}



	void StartHostedNetwork()
	{
		HANDLE ClientHandle;
		DWORD NegotiatedVersion;

		if (WlanOpenHandle(2, NULL, &NegotiatedVersion, &ClientHandle) != ERROR_SUCCESS)
			throw "WlanOpenHandle调用失败。";

		DWORD ReturnValue;
		BOOL Enabled = TRUE;
		WLAN_HOSTED_NETWORK_REASON FailReason;

		//如果承载网络被禁用（即netsh wlan set hostednetwork mode=disallow的作用），则先解除禁用状态。
		if (!_network_1_Enabled) {
			ReturnValue = WlanHostedNetworkSetProperty(
				ClientHandle,
				wlan_hosted_network_opcode_enable,
				sizeof(Enabled),
				(PVOID)&Enabled,
				&FailReason,
				NULL
			);
			if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkSetProperty启用承载网络失败。";
		}


		//启用承载网络。使用WlanHostedNetworkForceStart，即使本程序退出，承载网络仍会继续运行。
		if (WlanHostedNetworkForceStart(ClientHandle, &FailReason, NULL) != ERROR_SUCCESS)
			throw "WlanHostedNetworkForceStart调用失败。";

		WlanCloseHandle(ClientHandle, NULL);
	}


	void StopHostedNetwork()
	{
		HANDLE ClientHandle;
		DWORD NegotiatedVersion;

		if (WlanOpenHandle(2, NULL, &NegotiatedVersion, &ClientHandle) != ERROR_SUCCESS)
			throw "WlanOpenHandle调用失败。";

		WLAN_HOSTED_NETWORK_REASON FailReason;
		if (WlanHostedNetworkForceStop(ClientHandle, &FailReason, NULL) != ERROR_SUCCESS)
			throw "WlanHostedNetworkForceStop调用失败。";

		WlanCloseHandle(ClientHandle, NULL);
	}



	void DisableHostedNetwork()
	{
		HANDLE ClientHandle;
		DWORD NegotiatedVersion;

		if (WlanOpenHandle(2, NULL, &NegotiatedVersion, &ClientHandle) != ERROR_SUCCESS)
			throw "WlanOpenHandle调用失败。";

		DWORD ReturnValue;
		BOOL Enabled = FALSE;
		WLAN_HOSTED_NETWORK_REASON FailReason;

		ReturnValue = WlanHostedNetworkSetProperty(
			ClientHandle,
			wlan_hosted_network_opcode_enable,
			sizeof(Enabled),
			(PVOID)&Enabled,
			&FailReason,
			NULL
		);
		if (ReturnValue != ERROR_SUCCESS) throw "WlanHostedNetworkSetProperty禁用承载网络失败。";

		WlanCloseHandle(ClientHandle, NULL);

	}



	void EnumConnections(void(*Proc)(_NetConnectionInfo *NetConnectionInfo, _SharingType *SharingType, _ConnectingAction *ConnectingAction))
	{
		CoInitialize(NULL);
		CoInitializeSecurity(
			NULL,
			-1,
			NULL,
			NULL,
			RPC_C_AUTHN_LEVEL_PKT,
			RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL,
			EOAC_NONE,
			NULL
		);

		INetSharingManager * pNSM = NULL;
		HRESULT hr = ::CoCreateInstance(
			__uuidof(NetSharingManager),
			NULL, CLSCTX_ALL,
			__uuidof(INetSharingManager),
			(void**)&pNSM
		);
		if (!pNSM) throw L"NetSharingManager获取失败。";

		INetConnection * pNC = NULL;
		INetSharingEveryConnectionCollection * pNSECC = NULL;


		// 枚举设备(即本地连接，无线网络连接。。。)  
		hr = pNSM->get_EnumEveryConnection(&pNSECC);
		if (!pNSECC) {
			//pNSM->Release();
			throw L"get_EnumEveryConnection失败。";
		}


		IEnumVARIANT * pEV = NULL;
		IUnknown * pUnk = NULL;
		hr = pNSECC->get__NewEnum(&pUnk);
		if (pUnk)
		{
			hr = pUnk->QueryInterface(__uuidof(IEnumVARIANT), (void**)&pEV);
			if (!pEV) {
				//pNSM->Release();
				//pNSECC->Release();
				//pUnk->Release();
				throw L"QueryInterface失败。";
			}
		}
		else {
			//pNSM->Release();
			//pNSECC->Release();
			throw L"get__NewEnum失败。";
		}


		if (pEV)
		{
			VARIANT v;
			VariantInit(&v);// 初始化 错误 类型VARIANT（是错误可捕捉）  
			BOOL bFoundIt = FALSE;
			INetSharingConfiguration * pNSC = NULL;
			while (S_OK == pEV->Next(1, &v, NULL))// 枚举序列中的元素 ，返回错误值  
			{
				if (V_VT(&v) == VT_UNKNOWN)// 返回位置类型  
				{
					V_UNKNOWN(&v)->QueryInterface(__uuidof(INetConnection), (void**)&pNC);  // 查询设备是否支持接口  
					if (pNC)
					{
						NETCON_PROPERTIES* pNP = NULL;
						_NetConnectionInfo NetConnectionInfo;
						_SharingType SharingType, SharingType_old;
						_ConnectingAction ConnectingAction = ConnectingAction_None;

						pNC->GetProperties(&pNP);// 获取设备属性  
						NetConnectionInfo.DeviceName = pNP->pszwDeviceName;
						NetConnectionInfo.Name = pNP->pszwName;
						NetConnectionInfo.Status = pNP->Status;

						hr = pNSM->get_INetSharingConfigurationForINetConnection(pNC, &pNSC);
						if (hr != S_OK) throw L"get_INetSharingConfigurationForINetConnection调用失败。";
						VARIANT_BOOL SharingEnabled;
						SHARINGCONNECTIONTYPE SharingConnectionType;
						pNSC->get_SharingEnabled(&SharingEnabled);
						pNSC->get_SharingConnectionType(&SharingConnectionType);
						if (!SharingEnabled) {
							SharingType_old = SharingType = SharingType_None;
						}
						else {
							if (SharingConnectionType == ICSSHARINGTYPE_PUBLIC) SharingType_old = SharingType = SharingType_Public;
							if (SharingConnectionType == ICSSHARINGTYPE_PRIVATE) SharingType_old = SharingType = SharingType_Private;
						}

						(*Proc)(&NetConnectionInfo, &SharingType, &ConnectingAction);

						try {
							switch (SharingType)
							{
							case SharingType_None:
								if (SharingType_old != SharingType_None) {
									hr = pNSC->DisableSharing();
									if (hr != S_OK) throw L"DisableSharing调用失败。";
								}
								break;
							case SharingType_Private:
								if (SharingType_old != SharingType_Private) {
									hr = pNSC->EnableSharing(ICSSHARINGTYPE_PRIVATE);
									if (hr != S_OK) throw L"EnableSharing(ICSSHARINGTYPE_PRIVATE)调用失败。";
								}
								break;
							case SharingType_Public:
								if (SharingType_old != SharingType_Public) {
									hr = pNSC->EnableSharing(ICSSHARINGTYPE_PUBLIC);
									if (hr != S_OK) throw L"EnableSharing(ICSSHARINGTYPE_PUBLIC)调用失败。";
								}
								break;
							default:
								break;
							}

							switch (ConnectingAction)
							{
							case ConnectingAction_None:
								break;
							case ConnectingAction_Connect:
								if (pNC->Connect() != S_OK) throw L"Connect调用失败";
								break;
							case ConnectingAction_Disconnect:
								if (pNC->Disconnect() != S_OK) throw L"Disconnect调用失败";
								break;
							default:
								break;
							}
						}
						catch (char *Msg) {
							//pNSC->Release();
							//pNC->Release();
							//pEV->Release();
							//pUnk->Release();
							//pNSECC->Release();
							//pNSM->Release();
							throw Msg;
						}

						//pNSC->Release();
						//pNC->Release();
					}
				}
			}

		}
		//pEV->Release();
		//pUnk->Release();
		//pNSECC->Release();
		//pNSM->Release();

		CoUninitialize();

	}



	void SetWlanPowerState(bool PowerOn)
	{
		DWORD dwResult = 0;
		DWORD dwMaxClient = 2;
		DWORD dwCurVersion = 0;
		HANDLE hClient = NULL;
		PWLAN_INTERFACE_INFO_LIST pIfList = NULL;
		PWLAN_INTERFACE_INFO pIfInfo = NULL;

		dwResult = WlanOpenHandle(dwMaxClient, NULL, &dwCurVersion, &hClient);
		if (dwResult != ERROR_SUCCESS) {
			throw "WlanOpenHandle调用失败。";
		}

		dwResult = WlanEnumInterfaces(hClient, NULL, &pIfList);
		if (dwResult != ERROR_SUCCESS) {
			throw "WlanEnumInterfaces调用失败。";

		}


		DWORD DataSize;
		WLAN_PHY_RADIO_STATE *state;
		dwResult = WlanQueryInterface(hClient, &pIfList->InterfaceInfo[0].InterfaceGuid, wlan_intf_opcode_radio_state, NULL, &DataSize, (PVOID*)&state, NULL);

		state->dwPhyIndex = 0;
		state->dot11SoftwareRadioState = PowerOn ? dot11_radio_state_on : dot11_radio_state_off;

		if (state->dot11HardwareRadioState == state->dot11SoftwareRadioState) return;
		dwResult = WlanSetInterface(hClient, &pIfList->InterfaceInfo[0].InterfaceGuid,
			wlan_intf_opcode_radio_state, sizeof(WLAN_PHY_RADIO_STATE), state, NULL);

		WlanFreeMemory(state);

		if (dwResult != ERROR_SUCCESS) {
			throw "WlanSetInterface调用失败。";
		}

	}

}